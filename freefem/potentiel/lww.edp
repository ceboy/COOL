///////////////////////////////////////////////////////////////////////////////////
// PROBLEM PARAMETERS
///////////////////////////////////////////////////////////////////////////////////

include "input.idp"

int[int] I(0),J(0); real[int] C(0); // to get Morse storage of a matrix

exec("mkdir "+"./Result/"+geoname+"/");
string gpname = "./Result/"+geoname+"/potential.dat";

ofstream gpout(gpname);

///////////////////////////////////////////////////////////////////////////////////
// COMPUTATIONS (POSSIBLY FOR MANY MESHES) -- THIS IS VERY IMPORTANT !!
///////////////////////////////////////////////////////////////////////////////////
real erreta;
real errl2phi;
real errl2u1;
real errl2u2;
real errl2trphi;
real errl2var;
real errl2udN;
real errl2dno;
real[int] errl2tabphi(Nmesh); // stores L2 error of phi for each mesh
real[int] errl2tabu1(Nmesh); // stores L2 error of u1=dx(phi) for each mesh
real[int] errl2tabu2(Nmesh); // stores L2 error of u2=dy(phi) for each mesh
real[int] errl2tabtrphi(Nmesh); // stores L2 error of tr(phi) for each mesh
real[int] errl2tabudN(Nmesh); // stores L2 error of dn(phi) for each mesh
real[int] errl2tabvar(Nmesh); // stores L2 error of varphi for each mesh
real[int] errl2tabdno(Nmesh); // stores L2 error of DNO(phi) for each mesh
real H;
//Nmesh=1;
real dt;
for (int mymesh = 1; mymesh <= Nmesh; mymesh++)
{
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  mesh Th = readmesh("./Mesh/"+geoname+"mesh"+mymesh+".msh"); //plot(Th,wait=wait4plot);
  fespace ThP1(Th,P1); ThP1 hloc=hTriangle;
  real[int] htab(ThP1.ndof); htab(0:ThP1.ndof-1)=hloc[];
  real hsum=htab.sum; real hnbr=htab.n;
  H=hsum/hnbr;
  exec("mkdir "+"./Result/"+geoname+"mesh"+mymesh);
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** FINITE-ELEMENT SPACES
  fespace PHIh(Th,phiFE); // cout << PHIh.ndof << endl;
  fespace Uh(Th,uFE); // cout << Uh.ndof << endl;
  PHIh phi,psi,eta,etatemp,phitemp;
  Uh u1,u2,v1,v2;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** FINITE-ELEMENT CONNECTIVITY
  int[int] bndrypotential(0),bndryflux(0); // ** stores edges numbers labelled for Neumann or Dirichlet BC
  int[int] bndryperiodic1(0),bndryperiodic2(0); // ** periodic edges (+ list of permutations: to be matched)
  int[int] bndryfreesurface(0); // ** stores edges numbers labelled for Free-Surface BC
  real[int] xtabfreesurface(0);
  bool potentialon=false;
  bool fluxon=false;
  bool freesurface=false;
  bool periodicon = false;
  matrix bndryconnectivity; // ** Th.nbe lines containing as many dofs as linked to the boundary edge (2 for 2D P1)
  int[int] bndryconnectsize(Th.nbe); // ** current number of dofs per boundary edge (number of columns above)
  bndryconnectsize=0;
  I.resize(0);J.resize(0);C.resize(0);
  for(int e=0; e<Th.nbe; e++) // ** for each boundary edge e
  {
    if(tlabel(Th.be(e).label)==0){
      potentialon=true;
      bndrypotential.resize(bndrypotential.n+1);
      bndrypotential(bndrypotential.n-1)=e;
    }
    if(tlabel(Th.be(e).label)==1){
      fluxon=true;
      bndryflux.resize(bndryflux.n+1);
      bndryflux(bndryflux.n-1)=e;
    }
    if(tlabel(Th.be(e).label)==2){
      freesurface=true;
      bndryfreesurface.resize(bndryfreesurface.n+1);
      bndryfreesurface(bndryfreesurface.n-1)=e;
      xtabfreesurface.resize(xtabfreesurface.n+1);
      xtabfreesurface(xtabfreesurface.n-1)=(Th.be(e)[0].x+Th.be(e)[1].x)/2.;
   }
    if(tlabel(Th.be(e).label)==3){ // ** one has next to connect with other ones attached to "periodic" edges !!
      //cout<<e<<" : "<<Th.be(e)[0]<<" "<<"("<<Th.be(e)[0].x<<","<<Th.be(e)[0].y<<")";
      //cout<<" "<<Th.be(e)[1]<<"("<<Th.be(e)[1].x<<","<<Th.be(e)[1].y<<")"<<endl;
      periodicon=true;
      bndryperiodic1.resize(bndryperiodic1.n+1);
      bndryperiodic1(bndryperiodic1.n-1)=e;
      bndryperiodic2.resize(bndryperiodic2.n+1);
      bndryperiodic2(bndryperiodic2.n-1)=-1; // ** remains to be matched
    }
    int k = Th.be(e).Element; // ** get the corresponding element in which it is contained
    //cout<<e<<" : "<<Th.be(e)[0]<<" "<<Th.be(e)[1]<<" , label "<<Th.be(e).label<<" tria "<<k<<endl;
    // ** Th.be(k).whoinElement yields the edge number within element int(Th.be(k).Element)
    // ** int ee,eee=Th.be(k).whoinElement; ( Th[k].adj((ee=eee)) != Th[k]) checks if on boundary
    for(int j=0; j<PHIh.ndofK; j++){ // ** for each dof of the element with boundary edge
      int idof = PHIh(k,j); // ** does the dof support intersect the boundary ? (only 2 among 3 per element in 2D)
      psi = 0; psi[][idof] = 1; //plot(psi,wait=1);
      //cout<<idof<<" at edge vertices "<<psi(Th.be(e)[0].x,Th.be(e)[0].y)+psi(Th.be(e)[1].x,Th.be(e)[1].y)<<endl;
      real mytest = int1d(Th,Th.be(e).label)(psi*psi); // ** Th.be(e).label: geometric label, tlabel(Th.be(e).label): BC
      if(mytest>0.){ //plot(psi,wait=1);
        I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
        I(I.n-1)=e; J(J.n-1)=bndryconnectsize(e); C(C.n-1)=idof;
        bndryconnectsize(e) += 1;
        //cout << mytest << " edge " << e <<" "<<bndryconnectsize(e)<<"th dof :"<< idof << endl; plot(v,wait=1);
      }
    }
  }
  if(!freesurface==true){
    cout << " No free-surface boundary : problem, this is a free-surface simulation " << endl;
    break;
  }
  bndryconnectivity = [I,J,C]; //cout<<bndryconnectivity<<endl; // ** all dofs should be listed twice in P1 2D
  // ** checks mesh compatibility and builds the matching for periodic edges (permutation bndryperiodic2)
  //cout << bndryperiodic1 << endl; cout << bndryperiodic2 << endl;
  for(int e=0; e<bndryperiodic1.n; e++) // ** for each boundary edge e
  {
    if(bndryperiodic2(e)==-1){ // ** points to be matched: result will be in bndryperiodic2(e);
      bndryperiodic2(e)=Th.nbe; // ** exclude from search below, but give an unrealistic value
      //cout<<bndryperiodic1(e)<< " : "<<Th.be(bndryperiodic1(e))[0]<<" "<<Th.be(bndryperiodic1(e))[1]<<endl;
      //cout<<"("<<Th.be(bndryperiodic1(e))[0].x<<","<<Th.be(bndryperiodic1(e))[0].y<<")"<<" ";
      //cout<<"("<<Th.be(bndryperiodic1(e))[1].x<<","<<Th.be(bndryperiodic1(e))[1].y<<")"<<endl;
      real[int] point1 = [Th.be(bndryperiodic1(e))[0].x,Th.be(bndryperiodic1(e))[0].y];
      real[int] point2 = [Th.be(bndryperiodic1(e))[1].x,Th.be(bndryperiodic1(e))[1].y];
      //cout << "point 1 " << point1 << endl; cout << "point 2 " << point2 << endl;
      real[int] trans1(2); trans1 = ROTATION*point1;
      trans1 = trans1 + TRANSLATION; //cout << point1 << " -> " << trans1 << endl;
      real[int] trans2(2); trans2 = ROTATION*point2;
      trans2 = trans2 + TRANSLATION; //cout << point2 << " -> " << trans2 << endl;
      int mytest = 0;
      int ee=-1;
      while(!mytest&&ee<bndryperiodic1.n-1){
        ee++;
        if(bndryperiodic2(ee)<0){ // ** perioridc boundary edge not already matched
	  //cout<<"("<<Th.be(bndryperiodic1(ee))[0].x<<","<<Th.be(bndryperiodic1(ee))[0].y<<")"<<" ";
	  //cout<<"("<<Th.be(bndryperiodic1(ee))[1].x<<","<<Th.be(bndryperiodic1(ee))[1].y<<")"<<endl;
	  real[int] point3 = [Th.be(bndryperiodic1(ee))[0].x,Th.be(bndryperiodic1(ee))[0].y];
	  real[int] point4 = [Th.be(bndryperiodic1(ee))[1].x,Th.be(bndryperiodic1(ee))[1].y];
	  //cout << "point 3 " << point3 << endl; cout << "point 4 " << point4 << endl;
	  real[int] trans3(2); trans3 = ROTATION*point3;
	  trans3 = trans3 + TRANSLATION; //cout << point3 << " -> " << trans3 << endl;
	  real[int] trans4(2); trans4 = ROTATION*point4;
	  trans4 = trans4 + TRANSLATION; //cout << point4 << " -> " << trans4 << endl;
	  real[int] test1(2),test2(2);
	  test1 = trans1 + (-1.)*point3;
	  test2 = trans2 + (-1.)*point4; //cout << test1 << endl; cout << test2 << endl;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*1324; // 1->3,2->4
	  test1 = trans1 + (-1.)*point4;
	  test2 = trans2 + (-1.)*point3;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*1423; // 1->4,2->3
	  test1 = trans3 + (-1.)*point1;
	  test2 = trans4 + (-1.)*point2;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*3142; // 3->1,4->2
	  test1 = trans3 + (-1.)*point2;
	  test2 = trans4 + (-1.)*point1;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*3241; // 3->2,4->1
	}
	//cout << " At " << ee << " < " << bndryperiodic1.n << " : " << mytest << endl;
      }
      //cout << " Out at " << ee << " : " << mytest << endl;
      if(mytest==1324){
        bndryperiodic2(e)=bndryperiodic1(ee);
        bndryperiodic2(ee)=-2; // ** matched message (not used yet): edge not rotated
      } else if(mytest==1423){
        bndryperiodic2(e)=bndryperiodic1(ee);
        bndryperiodic2(ee)=-3; // ** matched message (not used yet): edge rotated
      } else if(mytest==3142){
        bndryperiodic2(ee)=bndryperiodic1(e);
        bndryperiodic2(e)=-2; // ** matched message (not used yet): edge not rotated
      } else if(mytest==3241){
        bndryperiodic2(ee)=bndryperiodic1(e);
        bndryperiodic2(e)=-3; // ** matched message (not used yet): edge rotated
      } else {
	cout<<"Problem matching periodic edge "<< e << " at " << ee << " < " <<  bndryperiodic1.n << endl;
	break;
      }
    }
  } // cout << bndryperiodic1 << endl; cout << bndryperiodic2 << endl;
  // ** the match bndryperiodic1 <-> bndryperiodic2 should be exactly a permutation between edges of the mesh
  // ** we now build the match between dofs(bndryperiodic1) <-> dofs(bndryperiodic2)
  int[int] dofperiodic1(0),dofperiodic2(0); // ** "periodic" identified dofs (list and permutation to be matched)
  for(int e=0; e<bndryperiodic1.n; e++) // ** for each boundary edge e
  {
    int e1 = bndryperiodic1(e); // cout << e1 << endl;
    int e2 = bndryperiodic2(e); // cout << e2 << endl;
    if(e1>0&&e2>0){ // ** the result of matching bndryperiodic1->bndryperiodic2 has allowed to filter when edge2=translation+rotation(edge1)
      int[int] dofs1(bndryconnectsize(e1)); for(int i=0;i<bndryconnectsize(e1);i++){ dofs1(i)= bndryconnectivity(e1,i); }
      int[int] dofs2(bndryconnectsize(e2)); for(int i=0;i<bndryconnectsize(e2);i++){ dofs2(i)= bndryconnectivity(e2,i); }
      for(int i=0;i<dofs1.n;i++){
	phi = 0; phi[][dofs1(i)] = 1; //plot(phi,wait=1,value=true,fill=1,cmm="dofs1");
	for(int j=0;j<dofs2.n;j++){
	  psi = 0; psi[][dofs2(j)] = 1; //plot(psi,wait=1,value=true,fill=1,cmm="dofs2");
	  //cout << "TRANSLATION " << TRANSLATION(0) << " " << TRANSLATION(1) << endl;
	  phitemp = psi(TRANSLATION(0)+ROTATION(0,0)*x+ROTATION(0,1)*y,TRANSLATION(1)+ROTATION(1,0)*x+ROTATION(1,1)*y) + (-1.)*phi; //plot(uu,wait=1,value=true,fill=1);
	  //func real utrans(real x,real y){ return u(x+1.,y); } //uu = v + (-1.)*utrans; plot(v,wait=1,fill=1); // ** another implementation
	  // ** test: glue shape functions & define a new (continuous) FE function ? compare C0 DOFs & reject dc DOFs
	  real mytest = int1d(Th,Th.be(e1).label)(square(phitemp)); // ** all dofs are continuous here
	  if(mytest==0.){
	    //uu = v + u; plot(uu,wait=1,value=true,fill=1,cmm="periodic dof");
	    //cout << "Periodic dof matching : " << dofs1(i) << " <-> " << dofs2(j) << " from edges " << e1 << " <-> " << e2 << endl;
	    dofperiodic1.resize(dofperiodic1.n+1);
	    dofperiodic1(dofperiodic1.n-1)=dofs1(i);
	    dofperiodic2.resize(dofperiodic2.n+1);
	    dofperiodic2(dofperiodic2.n-1)=dofs2(j);
	  }
	}
      }
    }
  } // cout << dofperiodic1 << endl; cout << dofperiodic2 << endl; // ** periodid dofs appear as many times as the number of periodic edge they belong to
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** STANDARD VARIATIONAL FORMULATION: freeze Dirichlet dofs (Dpotentialon) = essential
  real[int] ones(PHIh.ndof), zeros(PHIh.ndof); ones = 1.; zeros = 0.;
  matrix Atemp, Atp;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** we assume here that the nature of the boundaries (Neumann, Dirichlet, peioridc) is constant with time
  // ** we build a diagonal matrix with 0, or 1 where dof is  boundary+"potential"(Dirichlet)
  I = [PHIh.ndof-1]; J = [PHIh.ndof-1]; C = [0.]; matrix Dpotentialon = [I,J,C];
  if(potentialon){
    I.resize(0);J.resize(0);C.resize(0); // cout << bndryconnectivity << endl;
    for(int e=0; e<bndrypotential.n; e++) { // ** alternative construction without +on
      int ee = bndrypotential(e); // ** edge associated with a potential BC
      int myndof = bndryconnectsize(ee);
      for(int i=0;i<myndof;i++){
        int mydof = bndryconnectivity(ee,i);
	//psi[]=0;psi[](mydof)= 1;plot(psi,[v1,v2],wait=1,cmm="pot");
        I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
        I(I.n-1)=mydof; J(J.n-1)=mydof; C(C.n-1)=1;
      }
    }
    Atemp = [I,J,C];
    Atp = Dpotentialon + Atemp; //cout << " Dpotentialon " << Dpotentialon << endl;
    [I,J,C] = Atp;
    Dpotentialon = [I,J,C]; // ** cleans Morse storage
  } //cout << " Dpotentialon " << Dpotentialon << endl;
  // ** all dofs with one edge Dirichlet are essential
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  //cout << "dofperiodic1 " << dofperiodic1 << endl;
  //cout << "dofperiodic2 " << dofperiodic2 << endl;
  matrix Asum = [ones]; // ** identity matrix
  I = [PHIh.ndof-1]; J = [PHIh.ndof-1]; C = [0.]; matrix Aperiodic = [I,J,C];
  if(periodicon){
    Atemp = [dofperiodic2,dofperiodic1,ones(0:dofperiodic2.n-1)]; // ** tests dofs from dofperiodic2 are enlarged with tests dof from dofperiodic1
    //psi=0; for(int i=0;i<dofperiodic2.n;i++) psi[](dofperiodic2(i))=1.; plot(psi,wait=1,fill=1,cmm="Linear system matching enforced");
    Atp = Asum + Atemp; //cout << " Atp " << Atp << endl; //cout << " Atemp " << Atemp << endl;
    [I,J,C] = Atp; C=1;
    Asum = [I,J,C]; //cout << " Asum " << Asum << endl;
    I.resize(0);J.resize(0);C.resize(0);
    for(int i=0; i<dofperiodic1.n; i++){ // ** for each periodic dof
      int dof1 = dofperiodic1(i); // ** trial dofs from dofperiodic1 are made equal to trial dofs from dofperiodic2
      bool test=false; // ** select pairs of matching edges once only
      // for(int i=0; i<I.n; i++){ if(I(i)==dof1||J(i)==dof1) test=true; }
      for(int i=0; i<I.n; i++){ if(I(i)==dof1) test=true; }
      if(!test){
	I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
	I(I.n-1)=dof1; J(J.n-1)=dof1; C(C.n-1)=1.;
	I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
	I(I.n-1)=dof1; J(J.n-1)=dofperiodic2(i); C(C.n-1)=-1;
      }
    }
    Atemp = [I,J,C];
    Atp = Aperiodic + Atemp; //cout << " Aperiodic " << Aperiodic << endl;
    [I,J,C] = Atp;
    Aperiodic = [I,J,C]; // ** cleans Morse storage
  }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** we build a diagonal matrix with 0, or 1 where dof is  boundary+"free-surface"(Dirichlet/Neumann)
  I = [PHIh.ndof-1]; J = [PHIh.ndof-1]; C = [0.];
  matrix Dfreesurface = [I,J,C]; //cout << bndryfreesurface << endl;
  I.resize(0);J.resize(0);C.resize(0); //cout << bndryconnectivity << endl;
  for(int e=0; e<bndryfreesurface.n; e++) { // ** alternative construction without +on
    int ee = bndryfreesurface(e); // cout << ee << endl;  // cout << bndryconnectivity(ee,:) << endl;
    int myndof = bndryconnectsize(ee);
    for(int i=0;i<myndof;i++){
      int mydof = bndryconnectivity(ee,i);
      //etatemp[]=0;etatemp[](mydof)= 1;plot(etatemp,wait=1,cmm="freesurf");
      I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
      I(I.n-1)=mydof; J(J.n-1)=mydof; C(C.n-1)=1;
    }
  }
  Atemp = [I,J,C];
  Atp = Dfreesurface + Atemp; //cout << " Dfreesurface " << Dfreesurface << endl;
  [I,J,C] = Atp;
  Dfreesurface = [I,J,C]; // ** cleans Morse storage
  // ** BE CAREFUL: AT THIS STAGE, THERE IS OVERLAP BETWEEN Dpotentialon AND Dfreesurface !!
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  varf vftemp(phi,psi) = int2d(Th)(dx(phi)*dx(psi)+dy(phi)*dy(psi)/hwave^2);
  Atemp = vftemp(PHIh,PHIh);
  matrix A = Asum*Atemp; // ** sum lines with matching test dof (linear system with non zero kernel !)
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] diagAperiodic(PHIh.ndof); //cout << Aperiodic << endl;
  diagAperiodic = Aperiodic.diag; //v=0; v[]=diagAperiodic; plot(v,wait=1,fill=1,cmm="Periodic matching enforced");
  matrix Dperiodic = [diagAperiodic]; [I,J,C] = Dperiodic; Dperiodic = [I,J,C]; //cout << Dperiodic << endl;
  Atemp = Dperiodic*A;
  Atp = A + (-1.)*Atemp;
  A = Atp + Aperiodic; // ** extraction of periodic dofs merged by Asum, to be set by Aperiodic
  matrix Afull = A;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] diagDfixed(PHIh.ndof); //cout << Dpotentialon << endl;
  diagDfixed = Dpotentialon.diag; // ** primal formulation: Dirichlet BC essential
  real[int] diagDfreesurface(PHIh.ndof); //cout << Dfreesurface << endl;
  diagDfreesurface = Dfreesurface.diag;
  diagDfreesurface = diagDfreesurface ? ones : zeros; // ** useless if connected // cout << diagDfreesurface << endl;
  // ** BE CAREFUL: AT THIS STAGE, diagDfreesurface still contains some overlap with diagDfixed !!
  // ** THIS IS A PROBLEM FOR DNO: the boundary edge of a dof cannot half essential half natural //<<<<<<<<<
  //psi = 0; psi[] = diagDfreesurface; plot(psi,wait=1,fill=1,cmm="freesurface dofs");
  diagDfreesurface = diagDfixed ? zeros : diagDfreesurface; // ** to clean out intersecting Dirichlet dof
  //psi = 0; psi[] = diagDfreesurface; plot(psi,wait=1,fill=0,cmm="freesurface dofs");
  // ** BE CAREFUL: AT THIS STAGE, diagDfreesurface does not overlap diagDfixed anymore !!
  Dfreesurface = [diagDfreesurface]; [I,J,C] = Dfreesurface; Dfreesurface = [I,J,C]; // ** cleans Morse storage
  diagDfixed = diagDfixed + diagDfreesurface; // ** primal formulation: Dirichlet-to-Neumann
  diagDfixed = diagDfixed ? ones : zeros; //cout <<  diagDfixed << endl;
  matrix Dfixed = [diagDfixed]; [I,J,C] = Dfixed; Dfixed = [I,J,C]; // ** cleans Morse storage
  Atemp = Dfixed*A;
  Atp = A + (-1.)*Atemp;  // ** extraction of essential dofs
  A = Atp + Dfixed;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // $$$$$ TIME INITIALIZATION $$$$$
  dt=.01; // constant time step
  exec("mkdir "+"./Result/"+geoname+"mesh"+mymesh+"/dt"+dt);
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] seqenergy(0);  ofstream outenergy("./Result/"+geoname+"/mesh"+mymesh+"/dt"+dt+"/energy.txt");
  real[int] seqerreta(0);  ofstream outerreta("./Result/"+geoname+"/mesh"+mymesh+"/dt"+dt+"/erreta.txt");
  real[int] seqerrphi(0);  ofstream outerrphi("./Result/"+geoname+"/mesh"+mymesh+"/dt"+dt+"/errphi.txt");
  real[int] seqerrvar(0);  ofstream outerrvar("./Result/"+geoname+"/mesh"+mymesh+"/dt"+dt+"/errvar.txt");
  real[int] seqerrdno(0);  ofstream outerrdno("./Result/"+geoname+"/mesh"+mymesh+"/dt"+dt+"/errdno.txt");
  int nbiter=0;
  real tt,t; // current times for eta and phi equations respectively
  if(starteta){ // tt=t-dt/2.; time shift velocity-verlet TO START BY UPDATING ETA (using DNO)
    t=0.;
    tt=-dt/2.;
  } else { // tt=t+dt/2.; time shift velocity-verlet TO START BY UPDATING PHI (using DNO)
    t=-dt/2.;
    tt=0.;
  }
  eta = etaana(tt,x); // plot(eta,wait=1); // ** eta can be defined everywhere provided the trace dof are correct
  phi = phiana(t,x,y);
  u1 = dx(phi);
  u2 = dy(phi); u2=u2/hwave;
  real energy=(1./2.)*(int2d(Th)(u1*u1+u2*u2));
  for(int i=1;i<=nblabel;i++){
    if(tlabel(i)==2) energy = energy+int1d(Th,i)(gravity*eta*eta);
  }
  cout <<"Energy "<< energy <<endl;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // $$$$$ SURFACE $$$$$
  matrix MASS;
  for(int i=1; i<=nblabel; i++){
    if(tlabel(i)==2){
      varf mass(phi,psi) = int1d(Th,i)(phi*psi);
      MASS = mass(PHIh,PHIh); // ** assumes free-surface connected (one label only)
    }
  } // cout << "Asum " << Asum << endl;
  Atemp = Asum*MASS; //cout << "Atemp " << Atemp << endl;
  Atp = Dperiodic*Atemp; MASS = Atemp + (-1.)*Atp; Atemp = MASS + Aperiodic; //cout << "Atp " << Atp << endl;
  [I,J,C] = Atemp; MASS = [I,J,C]; //cout << "MASS " << MASS << endl;
  [I,J,C] = Dfreesurface; //cout << Dfreesurface << endl;
  real ndoffreesurface = diagDfreesurface.sum; //=I.n-(C(I.n-1)==0); //cout << ndoffreesurface << endl;
  //cout << "Check last element " << C(I.n-1) << " " << C(I.n-1)==0 << endl;
  int[int] DOFfreesurface = I(0:ndoffreesurface-1); //cout << DOFfreesurface << endl;
  int[int] DOFall(0); DOFall = 0:PHIh.ndof-1;
  matrix PROJECTION = Dfreesurface(DOFfreesurface,DOFall); //cout << PROJECTION << endl;
  matrix LIFTING = Dfreesurface(DOFall,DOFfreesurface); //cout << LIFTING << endl;
  matrix MASSfreesurface = MASS(DOFfreesurface,DOFfreesurface); //cout << MASSfreesurface << endl;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] ytabfreesurface(xtabfreesurface.n);
  for(int i=0; i<xtabfreesurface.n; i++){ ytabfreesurface(i)=eta(xtabfreesurface(i),1.);}
  plot([xtabfreesurface,ytabfreesurface],wait=wait4plot,cmm="Free Surface at "+t+" [s]");//,ps="freesurface.eps"
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] b(PHIh.ndof),bfull(PHIh.ndof);
  // $$$$$ TIME LOOP $$$$$
while(t<Tfinal&&nbiter<Nbitermax)
{
 if(tt<t){ // ** start Verlet with updating eta before phi
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** DNO OPERATOR
  varf volumesrc(phi,psi) = int2d(Th)(mddxxmddzzphiana(t,x,y)*psi);
  b = volumesrc(0,PHIh); // source term without essential BC
  for(int i=1; i<=nblabel; i++){
    varf vftemp(phi,psi) = int1d(Th,i,qforder=10)(fluxBC*psi);
    real[int] temp = vftemp(0,PHIh);
    if(tlabel(i)==1){ // flux BC are natural
      b += temp;
    }
  }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  bfull = Asum*b;
  b = diagAperiodic ? zeros : bfull; // ** periodic BC !! STRONG !!
  bfull = b;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  b = diagDfixed ? phi[] : b ; // source term with Dirichlet BC !! STRONG !!
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] U(PHIh.ndof),V(PHIh.ndof),W(PHIh.ndof),VEC(PHIh.ndof);
  set(A,eps=eps4solver,solver=mysolver,dimKrylov=150); //,tgv=1e30
  U=A^-1*b;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  phi[] = U; //phi = phiana(tt,x,y);
  u1 = dx(phi);
  u2 = dy(phi); u2=u2/hwave;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** POST-PROCESSING
  // ofstream Ufile ("./Result/"+geoname+"mesh"+mymesh+"/phi.txt"); Ufile<<phi[];
  // ** PLOT
  //plot(Th,phi,fill=1,value=true,wait=wait4plot,cmm="phi");
  //psi = phiana(tt,x,y); plot(Th,psi,fill=1,value=true,wait=wait4plot,cmm="phiana");
  plot(Th,phi,[u1,u2],value=true,wait=wait4plot,cmm="phi and u");
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** CHECK OUTPUT ERRORS
  psi = phiana(t,x,y)-phi; //plot(Th,psi,fill=1,value=true,wait=wait4plot,cmm="phierr");
  v1 = dxphiana(t,x,y)-u1; //plot(Th,v1,fill=1,value=true,wait=wait4plot,cmm="u1err");
  v2 = dyphiana(t,x,y)-u2; v2=v2/hwave; //plot(Th,v2,fill=1,value=true,wait=wait4plot,cmm="u2err");
  //fespace P1dconTh(Th,P1dc); P1dconTh w; w = v1; // plot //w = v2;
  errl2phi = sqrt(int2d(Th)(square(psi)));
  errl2u1 = sqrt(int2d(Th)(square(v1)));
  errl2u2 = sqrt(int2d(Th)(square(v2)));
  if(errl2tabphi(mymesh-1)<errl2phi) errl2tabphi(mymesh-1)=errl2phi;
  if(errl2tabu1(mymesh-1)<errl2u1) errl2tabu1(mymesh-1)=errl2u1;
  if(errl2tabu2(mymesh-1)<errl2u2) errl2tabu2(mymesh-1)=errl2u2;
  // errl2tabphi(mymesh-1) = errl2phi;
  // errl2tabu1(mymesh-1) = errl2u1;
  // errl2tabu2(mymesh-1) = errl2u2;
  // ** TRACE (DIRICHLET OPERATOR: ESSENTIAL => ERROR STRONG)
  errl2trphi = 0;
  errl2var = 0;
  for(int i=1; i<=nblabel; i++){
    phitemp[]=0;
    for(int e=0; e<Th.nbe; e++){
      for(int j=0;j<bndryconnectsize(e);j++) if(Th.be(e).label==i) phitemp[](bndryconnectivity(e,j)) = 1.;
    } //plot(phitemp,wait=1,fill=1,cmm="label "+i);
    phitemp[] = phitemp[].*psi[];
    cout <<"Linf error trace on "<<i<<" = "<<phitemp[].linfty<< endl;
    real mytemp = int1d(Th,i)(square(psi));
    cout <<"L2 error trace on "<<i<<" = "<<sqrt(mytemp)<< endl;
    errl2trphi += mytemp;
    if(tlabel(i)==2) errl2var += mytemp;
  }
  if(errl2tabtrphi(mymesh-1)<errl2trphi) errl2tabtrphi(mymesh-1)=errl2trphi;
  if(errl2tabvar(mymesh-1)<errl2var) errl2tabvar(mymesh-1)=errl2var;
  // errl2tabtrphi(mymesh-1) = sqrt(errl2tabtrphi(mymesh-1)+errl2trphi);
  // errl2tabvar(mymesh-1) = sqrt(errl2tabvar(mymesh-1)+errl2var);
  // ** NORMAL TRACE (NEUMANN OPERATOR: NATURAL => ERROR WEAK)
  V = Afull*U; W = V + (-1.)*bfull; psi[] = W; // ** residual to be evaluated as a _trace_ error
  plot(Th,psi,fill=1,value=true,wait=wait4plot,cmm="sdotNerr");
  //V = A*U; W = V + (-1.)*b; phitemp[] = W; // ** linalg residual
  //cout <<"Linf syslin "<< phitemp[].linfty/phi[].linfty <<" vs full " <<psi[].linfty/phi[].linfty<< endl;
  errl2udN = 0;
  errl2dno = 0;
  for(int i=1; i<=nblabel; i++){
    phitemp[]=0.;
    for(int e=0; e<Th.nbe; e++){
      for(int j=0;j<bndryconnectsize(e);j++) if(Th.be(e).label==i) phitemp[](bndryconnectivity(e,j)) = 1.;
    }
    //for(int e=0; e<Th.nbe; e++){
    //  for(int j=0;j<bndryconnectsize(e);j++) if(Th.be(e).label!=i) phitemp[](bndryconnectivity(e,j)) = 0.;
    //} // ** uncomment these lines to check that the error is zero _inside_ neumann boundary domains
    phitemp[] = phitemp[].*psi[];
    cout <<"Linf error normal trace on "<<i<<" = "<<phitemp[].linfty<< endl;
    real mytemp = int1d(Th,i)(square(psi));
    cout <<"L2 error normal trace on "<<i<<" = "<<sqrt(mytemp)<< endl;
    errl2udN += mytemp;
    if(tlabel(i)==2) errl2dno += mytemp;
  }
  if(errl2tabudN(mymesh-1)<errl2udN) errl2tabudN(mymesh-1)=errl2udN;
  if(errl2tabdno(mymesh-1)<errl2dno) errl2tabdno(mymesh-1)=errl2dno;
  // errl2tabudN(mymesh-1) = sqrt(errl2tabudN(mymesh-1)+errl2udN);
  // errl2tabdno(mymesh-1) = sqrt(errl2tabdno(mymesh-1)+errl2dno);
  //cout <<"Global Linf error normal trace = " <<psi[].linfty<< endl;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // $$$$$ VERLETeta $$$$$
  phitemp[] = Afull*phi[];
  phitemp[] = phitemp[] - bfull; // residual, DNO operator
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] normaltrace(ndoffreesurface), etatrace(ndoffreesurface);
psi[] = Asum*phitemp[]; //cout << phitemp[] << endl;cout << Asum << endl;
phitemp[] = diagAperiodic ? zeros : psi[]; //cout << phitemp[] << endl;
  normaltrace = PROJECTION*phitemp[]; // ** normal trace dof on free surface only
  // cout << MASSfreesurface << endl; [I,J,C] = MASSfreesurface;
  set(MASSfreesurface,eps=eps4solver,solver=mysolver,dimKrylov=150); //,tgv=1e30
  etatrace = MASSfreesurface^-1*normaltrace; //cout << etatrace << endl;
  etatemp[] = LIFTING*etatrace; // ** weak value
  //etatemp = dyphiana(tt,x,y)*(dt/hwave); // ** exact pointwise value // COMMENT TO CHECK NORMAL TRACE APPROXIMATION: problem with Dirichlet BC
  eta[] = eta[] + dt*etatemp[];
  //for(int i=0;i<xxfreesurface.n;i++) normaltrace(i)=phitemp(xxfreesurface[i],1.); cout<<normaltrace<<endl;
  tt = tt+dt;
  etatemp = etaana(tt,x);
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] yreffreesurface(xtabfreesurface.n);
  for(int i=0; i<xtabfreesurface.n; i++){ yreffreesurface(i)=etatemp(xtabfreesurface(i),1.); ytabfreesurface(i)=eta(xtabfreesurface(i),1.); }
  plot([xtabfreesurface,ytabfreesurface],[xtabfreesurface,yreffreesurface],wait=wait4plot,cmm="Free Surface and reference at "+t+" [s]",ps="freesurface.eps");//,ps="freesurface.eps"
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  etatemp = etatemp + (-1.)*eta;
  erreta = 0;
  for(int i=0;i<nblabel;i++){ if(tlabel(i)==2) erreta+=int1d(Th,i)(square(etatemp)); }
 }
 if(starteta&&nbiter>0){
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  energy = (1./2.)*(int2d(Th)(u1*u1+u2*u2));
  for(int i=1;i<=nblabel;i++){
    if(tlabel(i)==2) energy = energy+int1d(Th,i)(gravity*eta*eta);
  }
  seqenergy.resize(nbiter); seqenergy(nbiter-1)=energy;
  //seqerrphi.resize(nbiter); seqerrphi(nbiter-1)=errl2phi/sqrt(int2d(Th)(phi));
  seqerrphi.resize(nbiter); seqerrphi(nbiter-1)=errl2u1+errl2u2;
  seqerreta.resize(nbiter); seqerreta(nbiter-1) = erreta;
  // real myref1 = 0; for(int i=0;i<nblabel;i++){ if(tlabel(i)==2) myref1+=int1d(Th,i)(phi*phi); }
  // seqerrvar.resize(nbiter); seqerrvar(nbiter-1)=errl2tabvar(mymesh-1)/sqrt(myref1); // ** one could also put H1 error here
  // real myref2 = 0; for(int i=0;i<nblabel;i++){ if(tlabel(i)==2) myref2+=int1d(Th,i)(dy(phi)*dy(phi)); }
  // seqerrdno.resize(nbiter); seqerrdno(nbiter-1)=errl2tabdno(mymesh-1)/sqrt(myref2); // ** one could also put H1 error here
  seqerrvar.resize(nbiter); seqerrvar(nbiter-1)=errl2var;
  seqerrdno.resize(nbiter); seqerrdno(nbiter-1)=errl2dno;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  {outenergy << seqenergy(nbiter-1) << endl;}
  {outerrphi << seqerrphi(nbiter-1) << endl;}
  {outerreta << seqerreta(nbiter-1) << endl;}
  {outerrvar << seqerrvar(nbiter-1) << endl;}
  {outerrdno << seqerrdno(nbiter-1) << endl;}
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 }
 // ** HERE start Verlet with updating phi before eta
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // $$$$$ VERLETphi $$$$$
  phitemp = dpdt(t,x);
  psi = phi + dt*phitemp;
  phitemp = psi + (-1.)*dt*gravity*eta; //plot(eta,wait=1,fill=1); // ** phi has a "strong" trace (is an actual function): discrete eta is interpolated in the trace space
  t = t+dt;
  phi = phiana(t,x,y);
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  phi[] = diagDfreesurface ? phitemp[] : phi[]; //plot(phi,wait=1,fill=1); // ** modifies diagDfreesurface intersection with essential dofs if not cleaned above
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 if(!starteta&&nbiter>0){
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  energy = (1./2.)*(int2d(Th)(u1*u1+u2*u2));
  for(int i=1;i<=nblabel;i++){
    if(tlabel(i)==2) energy = energy+int1d(Th,i)(gravity*eta*eta);
  }
  seqenergy.resize(nbiter); seqenergy(nbiter-1)=energy;
  //seqerrphi.resize(nbiter); seqerrphi(nbiter-1)=errl2phi/sqrt(int2d(Th)(phi));
  seqerrphi.resize(nbiter); seqerrphi(nbiter-1)=errl2u1+errl2u2;
  seqerreta.resize(nbiter); seqerreta(nbiter-1) = erreta;
  // real myref1 = 0; for(int i=0;i<nblabel;i++){ if(tlabel(i)==2) myref1+=int1d(Th,i)(phi*phi); }
  // seqerrvar.resize(nbiter); seqerrvar(nbiter-1)=errl2tabvar(mymesh-1)/sqrt(myref1); // ** one could also put H1 error here
  // real myref2 = 0; for(int i=0;i<nblabel;i++){ if(tlabel(i)==2) myref2+=int1d(Th,i)(dy(phi)*dy(phi)); }
  // seqerrdno.resize(nbiter); seqerrdno(nbiter-1)=errl2tabdno(mymesh-1)/sqrt(myref2); // ** one could also put H1 error here
  seqerrvar.resize(nbiter); seqerrvar(nbiter-1)=errl2var;
  seqerrdno.resize(nbiter); seqerrdno(nbiter-1)=errl2dno;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  {outenergy << seqenergy(nbiter-1) << endl;}
  {outerrphi << seqerrphi(nbiter-1) << endl;}
  {outerreta << seqerreta(nbiter-1) << endl;}
  {outerrvar << seqerrvar(nbiter-1) << endl;}
  {outerrdno << seqerrdno(nbiter-1) << endl;}
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  nbiter++;
}
  // ** OUTPUT FILE
  {gpout << H <<"  "<< errl2tabphi(mymesh-1) <<"  "<< errl2tabu1(mymesh-1) <<"  "<< errl2tabu2(mymesh-1) <<"  "<< errl2tabtrphi(mymesh-1)
    <<"  "<< errl2tabudN(mymesh-1) <<"  "<< errl2tabvar(mymesh-1) <<"  "<< errl2tabdno(mymesh-1) << endl;}
    // ** mesh convergence for sup in time (alternative: pointwise-strong in time, last iteration)

}

/*
*/
