///////////////////////////////////////////////////////////////////////////////////
// INPUT PARAMETERS FOR poisson(mixedprimal/dual).edp
///////////////////////////////////////////////////////////////////////////////////

// ** Geometry: choose a family of meshes
int nblabel; // boundary edges are labelled from 1 to nblabel
//
// string geoname = "geo1"; nblabel = 4; // uniform square
// string geoname = "geo1bis"; nblabel = 4; // uniform square
// string geoname = "geo2"; nblabel = 3; // quarter of circle
string geoname = "geo3"; nblabel = 3; // triangle
// string geoname = "geo5"; nblabel = 4; // "bridge"
//
int Nmesh = 4; // number of meshes for the same geometry (refinements)
real[int] Tmesh(Nmesh);
//Tmesh(0) = 1;
for(int i=0; i<Nmesh; i++) Tmesh(i) = i+1;

// ** BVP type: choose condition for each boundary (label) 0=potential 1=flux 3=periodic
int[int]tlabel(nblabel+1);
if(nblabel>=1) tlabel[1] = 1;
if(nblabel>=2) tlabel[2] = 1;
if(nblabel>=3) tlabel[3] = 0;
if(nblabel>=4) tlabel[4] = 1;
matrix ROTATION; // we define an affine mapping between boundaries matching through periodic BC
int[int] Iloc = [0,0,1,1];
int[int] Jloc = [0,1,0,1];
real[int] Cloc = [1.,0.,0.,1.];
ROTATION = [Iloc,Jloc,Cloc]; // ** to avoid Morse storage cleaning of zeros
real[int] TRANSLATION = [1,0]; // geometric compatibility is checked before applying BC 3 on impacted DOF

// ** Data: choose an analytical solution to provide volume source, edge source, edge traces for BC

// ** analytical expression with correct BC for geo1 (upper-right square) 
// func uxana = sin(y*pi)*(1+cos(x*pi))/2.; 
// func uyana = -sin(x*pi)*(1+cos(y*pi))/2.;
// func fx = pi^2*sin(y*pi)*(1./2.+cos(x*pi));
// func fy = -pi^2*sin(x*pi)*(1./2.+cos(y*pi));
//          |\
//     ____ | |
//    /    \|/     1
// ------------------>
//   -1    /|\____/
//        | |
//         \|
// ** analytical expression with correct BC for geo3
// func u1ana = sin(x+y); 
// func u2ana = -sin(x+y);
// func dxu1ana = cos(x+y);
// func dyu1ana = cos(x+y);
// func dxu2ana = -cos(x+y);
// func dyu2ana = -cos(x+y);
// func mddxxmddyyu1ana = 2*sin(x+y);
// func mddxxmddyyu2ana = -2*sin(x+y);
func uu1ana = sin(x+y); 
func uu2ana = -sin(x+y);
func dxuu1ana = cos(x+y);
func dyuu1ana = cos(x+y);
func dxuu2ana = -cos(x+y);
func dyuu2ana = -cos(x+y);
func mddxxmddyyuu1ana = 2*sin(x+y);
func mddxxmddyyuu2ana = -2*sin(x+y);
// (BEWARE exact solution of FE pb too)
// func uxana = (x+y); 
// func uyana = -(x+y);
// func fx = 0.;
// func fy = 0.;

/*
real gravity = 9.81;
real hwave = 1; // water depth: equal to the geometry depth here !!
// !! next we use the variable change z+hwave=y*hwave and the equation is dxx(phi)+dyy(phi)/hwave^2=0 !!
real kwave = 1; // wave number << TO BE CHOSEN !!
//real Lwave = 1./kwave; // wave period in space
real wwave = sqrt(gravity*kwave*tanh(2*pi*kwave*hwave)/(2*pi)); // wave frequency (dispersion relation)
real Hwave = 0.05; // wave height (= cambrure dans un domaine de longueur 1)
// <= .01*g/wwave^2 and <= hwave + .001*g/wwave^2
// cout << "Cambrure = " << Hwave/hwave;
// cout << " Stokes " << .1/wwave^2;
// cout << " cnoidal " << hwave + .01/wwave^2 << endl;
real Twave = 1./wwave; // wave period in time
// cout << "Period = " << Twave << endl;
real t = 0.; // current time
func uana = (gravity*(Hwave/2.)*Twave)*(cosh(2.*pi*kwave*y*hwave)/cosh(2.*pi*kwave*hwave))*sin(2.*pi*(kwave*x-wwave*t))/(2.*pi);
func dxuana = (gravity*(Hwave/2.)*Twave)*(cosh(2.*pi*kwave*y*hwave)/cosh(2.*pi*kwave*hwave))*cos(2.*pi*(kwave*x-wwave*t))*kwave;
func dyuana = (gravity*(Hwave/2.)*Twave)*(sinh(2.*pi*kwave*y*hwave)*hwave/cosh(2.*pi*kwave*hwave))*sin(2.*pi*(kwave*x-wwave*t))*kwave;
func mddxxmddyyuana = 0;
func etaana=(Hwave/2)*cos(2.*pi*(kwave*x-wwave*t));
*/
// ** Numerical parameters: choose a FE space (for the potential), a Linalg solver and a precision
macro uFE P1 //potential space
macro sFE P0 //flux space (vector components)
macro usFE [sFE,sFE,uFE] //flux-potential (vector) space in primal mixed
macro suFE [RT0,P0] //flux-potential (vector) space in dual mixed
macro uuFE P1nc //potential space non-conforming
//
macro mysolver sparsesolver // UMFPACK // GMRES // CG //
real eps4solver = 1.e-15;
real eps4directsolvepena = 0.;//1.e-10;

// ** Output parameters: choose the level of outputs
//
int wait4plot = 1;
//
verbosity = 1;

