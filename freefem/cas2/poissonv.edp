///////////////////////////////////////////////////////////////////////////////////
// PROBLEM PARAMETERS
///////////////////////////////////////////////////////////////////////////////////

include "input.idp"

int[int] I(0),J(0); real[int] C(0); // ** to get Morse storage of a matrix

string gpname = "hcv.dat";

ofstream gpout(gpname);

///////////////////////////////////////////////////////////////////////////////////
// COMPUTATIONS (POSSIBLY FOR MANY MESHES) -- THIS IS VERY IMPORTANT !!
///////////////////////////////////////////////////////////////////////////////////

real[int] errl2tabu1(Nmesh); // stores L2 error of u1 for each mesh
real[int] errl2tabu2(Nmesh); // stores L2 error of u1 for each mesh
real[int] errl2tabs11(Nmesh); // stores L2 error of dx(u1) for each mesh
real[int] errl2tabs12(Nmesh); // stores L2 error of dy(u1) for each mesh
real[int] errl2tabs21(Nmesh); // stores L2 error of dx(u2) for each mesh
real[int] errl2tabs22(Nmesh); // stores L2 error of dy(u2) for each mesh
real[int] errl2tabtru1(Nmesh); // stores L2 error of tr(u1) for each mesh
real[int] errl2tabtru2(Nmesh); // stores L2 error of tr(u2) for each mesh
real[int] errl2tabs1dN(Nmesh); // stores L2 error of dn(u1) for each mesh
real[int] errl2tabs2dN(Nmesh); // stores L2 error of dn(u2) for each mesh
real H; // largest element dimension of the mesh
//Nmesh=1;
for (int mymesh = 1; mymesh <= Nmesh; mymesh++)
{
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  mesh Th = readmesh("./Mesh/"+geoname+"mesh"+mymesh+".msh");
  fespace ThP1(Th,P1); ThP1 hloc=hTriangle;
  real[int] htab(ThP1.ndof); htab(0:ThP1.ndof-1)=hloc[];
  real hsum=htab.sum; real hnbr=htab.n;
  H=hsum/hnbr;
  exec("mkdir "+"./Result/"+geoname+"mesh"+mymesh);
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** FINITE-ELEMENT SPACES
  fespace Uh(Th,uFE); Uh u1,u2,v1,v2,w1,w2;
  fespace UUh(Th,[uFE,uFE]); UUh [uu1,uu2],[vv1,vv2],[ww1,ww2];
  fespace Sh(Th,sFE); Sh s11,s12,s21,s22,t11,t12,t21,t22;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** FINITE-ELEMENT CONNECTIVITY
  int[int] bndrypotential(0),bndryflux(0); // ** edges labelled for Neumann or Dirichlet BC
  int[int] bndryperiodic1(0),bndryperiodic2(0); // ** periodic edges (+ list of permutations: to be matched)
  bool potentialon=false;
  bool fluxon=false;
  bool periodicon = false;
  matrix bndryconnectivity; // ** Th.nbe lines containing as many dofs as linked to the boundary edge (2 for 2D P1)
  int[int] bndryconnectsize(Th.nbe); // ** current number of dofs per boundary edge (number of columns above)
  bndryconnectsize=0;
  I.resize(0);J.resize(0);C.resize(0);
  for(int e=0; e<Th.nbe; e++) // ** for each boundary edge e
  {
    // ** a 2D edge is completely determined by e.g. two vertices
    //cout<<e<<" : "<<Th.be(e)[0]<<" "<<"("<<Th.be(e)[0].x<<","<<Th.be(e)[0].y<<")";
    //cout<<" "<<Th.be(e)[1]<<"("<<Th.be(e)[1].x<<","<<Th.be(e)[1].y<<")"<<endl;
    if(tlabel(Th.be(e).label)==0){
      potentialon=true;
      bndrypotential.resize(bndrypotential.n+1);
      bndrypotential(bndrypotential.n-1)=e;
    }
    if(tlabel(Th.be(e).label)==1){
      fluxon=true;
      bndryflux.resize(bndryflux.n+1);
      bndryflux(bndryflux.n-1)=e;
    }
    if(tlabel(Th.be(e).label)==3){ // ** "periodic" edges to be matched by pairs later on !!
      periodicon=true;
      bndryperiodic1.resize(bndryperiodic1.n+1);
      bndryperiodic1(bndryperiodic1.n-1)=e;
      bndryperiodic2.resize(bndryperiodic2.n+1);
      bndryperiodic2(bndryperiodic2.n-1)=-1; // ** remains to be matched
    }
    int k = Th.be(e).Element; // ** get the corresponding element in which it is contained
    //cout<<e<<" : "<<Th.be(e)[0]<<" "<<Th.be(e)[1]<<" , label "<<Th.be(e).label<<" tria "<<k<<endl;
    // ** Th.be(k).whoinElement yields the edge number within element int(Th.be(k).Element)
    // ** int ee,eee=Th.be(k).whoinElement; ( Th[k].adj((ee=eee)) != Th[k]) checks if on boundary
    for(int j=0; j<UUh.ndofK; j++){ // ** for each dof of the element with boundary edge
      int idof = UUh(k,j); // ** does the dof support intersect the boundary ? (only 2 among 3 per element in 2D)
      [vv1,vv2] = [0,0]; vv1[][idof] = 1; //plot([vv1,vv2],wait=1,cmm="dof "+idof);
      //cout<<idof<<" at edge vertices "<<v(Th.be(e)[0].x,Th.be(e)[0].y)+v(Th.be(e)[1].x,Th.be(e)[1].y)<<endl;
      real mytest = int1d(Th,Th.be(e).label)(vv1*vv1+vv2*vv2); // ** Th.be(e).label: geometric label, tlabel(Th.be(e).label): BC
      if(mytest>0.){
        I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
        I(I.n-1)=e; J(J.n-1)=bndryconnectsize(e); C(C.n-1)=idof; // ** idof is the dof number among all the mesh dofs
        bndryconnectsize(e) += 1;
        //cout << mytest << " edge " << e <<" "<<bndryconnectsize(e)<<"th dof :"<< idof << endl; plot(v,wait=1);
      }
    }
  }
  bndryconnectivity = [I,J,C]; //cout<<bndryconnectivity<<endl; // ** all dofs internal to a boundary domain should be listed twice in P1 2D
  // ** checks mesh compatibility and builds the matching for periodic edges (permutation bndryperiodic2)
  //cout << bndryperiodic1 << endl; cout << bndryperiodic2 << endl;
  for(int e=0; e<bndryperiodic1.n; e++) // ** for each boundary edge e
  {
    if(bndryperiodic2(e)==-1){ // ** points to be matched: result will be in bndryperiodic2(e);
      bndryperiodic2(e)=Th.nbe; // ** exclude from search below, give an unrealistic debug value
      //cout<<bndryperiodic1(e)<< " : "<<Th.be(bndryperiodic1(e))[0]<<" "<<Th.be(bndryperiodic1(e))[1]<<endl;
      //cout<<"("<<Th.be(bndryperiodic1(e))[0].x<<","<<Th.be(bndryperiodic1(e))[0].y<<")"<<" ";
      //cout<<"("<<Th.be(bndryperiodic1(e))[1].x<<","<<Th.be(bndryperiodic1(e))[1].y<<")"<<endl;
      real[int] point1 = [Th.be(bndryperiodic1(e))[0].x,Th.be(bndryperiodic1(e))[0].y];
      real[int] point2 = [Th.be(bndryperiodic1(e))[1].x,Th.be(bndryperiodic1(e))[1].y];
      //cout << "point 1 " << point1 << endl; cout << "point 2 " << point2 << endl;
      real[int] trans1(2); trans1 = ROTATION*point1;
      trans1 = trans1 + TRANSLATION; //cout << point1 << " -> " << trans1 << endl;
      real[int] trans2(2); trans2 = ROTATION*point2;
      trans2 = trans2 + TRANSLATION; //cout << point2 << " -> " << trans2 << endl;
      int mytest = 0;
      int ee=-1;
      while(!mytest&&ee<bndryperiodic1.n-1){
        ee++;
        if(bndryperiodic2(ee)<0){ // ** perioridc boundary edge not already matched
	  //cout<<"("<<Th.be(bndryperiodic1(ee))[0].x<<","<<Th.be(bndryperiodic1(ee))[0].y<<")"<<" ";
	  //cout<<"("<<Th.be(bndryperiodic1(ee))[1].x<<","<<Th.be(bndryperiodic1(ee))[1].y<<")"<<endl;
	  real[int] point3 = [Th.be(bndryperiodic1(ee))[0].x,Th.be(bndryperiodic1(ee))[0].y];
	  real[int] point4 = [Th.be(bndryperiodic1(ee))[1].x,Th.be(bndryperiodic1(ee))[1].y];
	  //cout << "point 3 " << point3 << endl; cout << "point 4 " << point4 << endl;
	  real[int] trans3(2); trans3 = ROTATION*point3;
	  trans3 = trans3 + TRANSLATION; //cout << point3 << " -> " << trans3 << endl;
	  real[int] trans4(2); trans4 = ROTATION*point4;
	  trans4 = trans4 + TRANSLATION; //cout << point4 << " -> " << trans4 << endl;
	  real[int] test1(2),test2(2);
	  test1 = trans1 + (-1.)*point3;
	  test2 = trans2 + (-1.)*point4; //cout << test1 << endl; cout << test2 << endl;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*1324; // 1->3,2->4
	  test1 = trans1 + (-1.)*point4;
	  test2 = trans2 + (-1.)*point3;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*1423; // 1->4,2->3
	  test1 = trans3 + (-1.)*point1;
	  test2 = trans4 + (-1.)*point2;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*3142; // 3->1,4->2
	  test1 = trans3 + (-1.)*point2;
	  test2 = trans4 + (-1.)*point1;
	  mytest = mytest + !(bool(test1.linfty+test2.linfty))*3241; // 3->2,4->1
	}
	//cout << " At " << ee << " < " << bndryperiodic1.n << " : " << mytest << endl;
      }
      //cout << " Out at " << ee << " : " << mytest << endl;
      if(mytest==1324){
        bndryperiodic2(e)=bndryperiodic1(ee);
        bndryperiodic2(ee)=-2; // ** matched message (not used yet): edge not rotated
      } else if(mytest==1423){
        bndryperiodic2(e)=bndryperiodic1(ee);
        bndryperiodic2(ee)=-3; // ** matched message (not used yet): edge rotated
      } else if(mytest==3142){
        bndryperiodic2(ee)=bndryperiodic1(e);
        bndryperiodic2(e)=-2; // ** matched message (not used yet): edge not rotated
      } else if(mytest==3241){
        bndryperiodic2(ee)=bndryperiodic1(e);
        bndryperiodic2(e)=-3; // ** matched message (not used yet): edge rotated
      } else {
	cout<<"Problem matching periodic edge "<< e << " at " << ee << " < " <<  bndryperiodic1.n << endl;
	break;
      }
    }
  } // cout << bndryperiodic1 << endl; cout << bndryperiodic2 << endl;
  // ** the match bndryperiodic1 <-> bndryperiodic2 should be exactly a permutation between edges of the mesh
  // ** we now build the match between dofs(bndryperiodic1) <-> dofs(bndryperiodic2)
  int[int] dofperiodic1(0),dofperiodic2(0); // ** "periodic" identified dofs (list and permutation to be matched)
  for(int e=0; e<bndryperiodic1.n; e++) // ** for each boundary edge e
  {
    int e1 = bndryperiodic1(e); //cout << e1 << endl;
    int e2 = bndryperiodic2(e); //cout << e2 << endl;
    if(e1>0&&e2>0){ // ** the result of matching bndryperiodic1->bndryperiodic2 has allowed to filter when edge2=translation+rotation(edge1), a one-to-one mapping between non-intersecting lists
      int[int] dofs1(bndryconnectsize(e1)); for(int i=0;i<bndryconnectsize(e1);i++){ dofs1(i)= bndryconnectivity(e1,i); }
      int[int] dofs2(bndryconnectsize(e2)); for(int i=0;i<bndryconnectsize(e2);i++){ dofs2(i)= bndryconnectivity(e2,i); }
      // ** at this stage we have to match each dofs1 to one dofs2... but which one ?
      for(int i=0;i<dofs1.n;i++){
	[uu1,uu2] = [0,0]; uu1[][dofs1(i)] = 1; //plot([uu1,uu2],wait=1,value=true,fill=1,cmm="dofs1");
	for(int j=0;j<dofs2.n;j++){
	  [vv1,vv2] = [0,0]; vv1[][dofs2(j)] = 1; //plot([vv1,vv2],wait=1,value=true,fill=1,cmm="dofs2");
	  //cout << "TRANSLATION " << TRANSLATION(0) << " " << TRANSLATION(1) << endl;
	  [ww1,ww2] = [vv1(TRANSLATION(0)+ROTATION(0,0)*x+ROTATION(0,1)*y,TRANSLATION(1)+ROTATION(1,0)*x+ROTATION(1,1)*y) + (-1.)*uu1,
	               vv2(TRANSLATION(0)+ROTATION(0,0)*x+ROTATION(0,1)*y,TRANSLATION(1)+ROTATION(1,0)*x+ROTATION(1,1)*y) + (-1.)*uu2];
	  //func real utrans(real x,real y){ return u(x+1.,y); } //w1 = v + (-1.)*utrans; plot(v,wait=1,fill=1); // ** another implementation
	  // ** test: glue shape functions & define a new (continuous) FE function ? compare C0 DOFs & reject dc DOFs
	  real mytest = int1d(Th,Th.be(e1).label)(square(ww1)+square(ww2)); // ** all dofs are continuous here
	  if(mytest==0.){
	    //w1 = v + u; plot(w1,wait=1,value=true,fill=1,cmm="periodic dof");
	    //cout << "Periodic dof matching : " << dofs1(i) << " <-> " << dofs2(j) << " from edges " << e1 << " <-> " << e2 << endl;
	    dofperiodic1.resize(dofperiodic1.n+1);
	    dofperiodic1(dofperiodic1.n-1)=dofs1(i);
	    dofperiodic2.resize(dofperiodic2.n+1);
	    dofperiodic2(dofperiodic2.n-1)=dofs2(j);
	  }
	}
      }
    }
  } //cout << dofperiodic1 << endl; cout << dofperiodic2 << endl;
  // ** periodic dofs appear as many times as the number of periodic edge they belong to
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** STANDARD VARIATIONAL FORMULATION: freeze Dirichlet dofs (Dpotentialon) = essential
  real[int] ones(UUh.ndof), zeros(UUh.ndof); ones = 1.; zeros = 0.;
  matrix Atemp, Atp;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** we build a diagonal matrix with 0, or 1 where dof is  boundary+"potential"(Dirichlet)
  I = [UUh.ndof-1]; J = [UUh.ndof-1]; C = [0.]; matrix Dpotentialon = [I,J,C];
  if(potentialon){
    I.resize(0);J.resize(0);C.resize(0); // cout << bndryconnectivity << endl;
    for(int e=0; e<bndrypotential.n; e++) { // ** alternative construction without +on
      int ee = bndrypotential(e); // ** edge associated with a potential BC
      int myndof = bndryconnectsize(ee);
      for(int i=0;i<myndof;i++){
        int mydof = bndryconnectivity(ee,i);
	//v[]=0;v[](mydof)= 1;plot(v,[t1,t2],wait=1,cmm="pot");
        I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
        I(I.n-1)=mydof; J(J.n-1)=mydof; C(C.n-1)=1;
      }
    }
    Atemp = [I,J,C];
    Atp = Dpotentialon + Atemp;
    [I,J,C] = Atp;
    Dpotentialon = [I,J,C]; // ** cleans Morse storage
  } //cout << " Dpotentialon " << Dpotentialon << endl;
  // ** all dofs with one edge Dirichlet are essential
  /*
  Atemp = 0;
  for(int i=1; i<=nblabel; i++){ // ** alternative construction with +on
    varf vftemp(u,v) = on(i,u=1); matrix temp = vftemp(Uh,Uh,tgv=1);
    if(tlabel(i)==0) Atemp = Atemp + temp;
  } //cout << Atemp << endl; // ** ==Dpotentialon
  */
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  //cout << "dofperiodic1 " << dofperiodic1 << endl;
  //cout << "dofperiodic2 " << dofperiodic2 << endl;
  matrix Asum = [ones]; // ** identity matrix, to become a transvection summing matching dofs in case of periodic BC
  I = [UUh.ndof-1]; J = [UUh.ndof-1]; C = [0.]; matrix Aperiodic = [I,J,C]; // ** zero matrix, for identification of matching dofs in case of periodic BC
  if(periodicon){
    Atemp = [dofperiodic2,dofperiodic1,ones(0:dofperiodic2.n-1)]; // ** tests dofs from dofperiodic2 are enlarged with tests dof from dofperiodic1
    //v=0; for(int i=0;i<dofperiodic2.n;i++) v[](dofperiodic2(i))=1.; plot(v,wait=1,fill=1,cmm="Linear system matching enforced");
    Atp = Asum + Atemp; //cout << " Atp " << Atp << endl;
    [I,J,C] = Atp; C=1;
    Asum = [I,J,C]; //cout << " Asum " << Asum << endl;
    I.resize(0);J.resize(0);C.resize(0);
    for(int i=0; i<dofperiodic1.n; i++){ // ** for each periodic dof
      int dof1 = dofperiodic1(i); // ** trial dofs from dofperiodic1 are made equal to trial dofs from dofperiodic2
      bool test=false; // ** select pairs of matching edges once only
      // for(int i=0; i<I.n; i++){ if(I(i)==dof1||J(i)==dof1) test=true; }
      for(int i=0; i<I.n; i++){ if(I(i)==dof1) test=true; }
      if(!test){
	I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
	I(I.n-1)=dof1; J(J.n-1)=dof1; C(C.n-1)=1.;
	I.resize(I.n+1); J.resize(J.n+1); C.resize(C.n+1);
	I(I.n-1)=dof1; J(J.n-1)=dofperiodic2(i); C(C.n-1)=-1;
      }
    }
    Atemp = [I,J,C];
    Atp = Aperiodic + Atemp; //cout << " Aperiodic " << Aperiodic << endl;
    [I,J,C] = Atp;
    Aperiodic = [I,J,C]; // ** cleans Morse storage
  }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  varf vftemp([uu1,uu2],[vv1,vv2]) 
   = int2d(Th)( dx(uu1)*dx(vv1)+dy(uu1)*dy(vv1) + dx(uu2)*dx(vv2)+dy(uu2)*dy(vv2) );
  Atemp = vftemp(UUh,UUh);
  matrix A = Asum*Atemp; // ** sum lines with matching test dof (linear system with non zero kernel !)
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] diagAperiodic(UUh.ndof); //cout << Aperiodic << endl;
  diagAperiodic = Aperiodic.diag; //v=0; v[]=diagAperiodic; plot(v,wait=1,fill=1,cmm="Periodic matching enforced");
  matrix Dperiodic = [diagAperiodic]; [I,J,C] = Dperiodic; Dperiodic = [I,J,C]; //cout << Dperiodic << endl;
  Atemp = Dperiodic*A;
  Atp = A + (-1.)*Atemp;
  A = Atp + Aperiodic; // ** extraction of periodic dofs merged by Asum, to be set by Aperiodic
  matrix Afull = A;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] diagDfixed(UUh.ndof);
  diagDfixed = Dpotentialon.diag; diagDfixed = diagDfixed ? ones : zeros; // ** sets one on the fixed dof (only nonzero previously)
  // ** some periodic dofs may already be enforced essentially when connected with edges of each type !! (check below)
  // cout << " check " << diagAperiodic(dofperiodic1(i))==1 << " " << diagAperiodic(dofperiodic2(i))==0 << " "<< diagDfixed(dofperiodic1(i))*diagDfixed(dofperiodic2(i))==0 << endl;
  matrix Dfixed = [diagDfixed]; [I,J,C] = Dfixed; Dfixed = [I,J,C]; // ** matrix needed later on for testlines extraction
  Atemp = Dfixed*A;
  Atp = A + (-1.)*Atemp;  // ** extraction of essential dofs
  A = Atp + Dfixed;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] b(UUh.ndof),bfull(UUh.ndof);
  varf volumesrc([uu1,uu2],[vv1,vv2]) = int2d(Th)(mddxxmddyyuu1ana*vv1+mddxxmddyyuu2ana*vv2);
  b = volumesrc(0,UUh); // ** source term without essential BC
  for(int i=1; i<=nblabel; i++){
    varf vftemp([uu1,uu2],[vv1,vv2]) = int1d(Th,i,qforder=10)((N.x*dxuu1ana+N.y*dyuu1ana)*vv1+(N.x*dxuu2ana+N.y*dyuu2ana)*vv2);
    real[int] temp = vftemp(0,UUh);
    if(tlabel(i)==1){ // ** flux BC are natural in primal
      b += temp;
    }
  }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  bfull = Asum*b;
  b = diagAperiodic ? zeros : bfull; // ** periodic BC !! STRONG !!
  bfull = b; // ** bfull keeps the trace of Dirichlet dofs intersecting a Neumann edge
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  [uu1,uu2] = [uu1ana,uu2ana]; // ** analytical expression with essential BC
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  b = diagDfixed ? uu1[] : b; // ** source term with essential BC !! STRONG !!
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** note that the choice below (periodic, next fixed) enforces essential BC for "mixed" dofs: important ?
  // ** SOLVABILITY (IN CASE OF SOLUTION IN QUOTIENT SPACE WITH FREDHOLM ALTERNATIVE: PURE NEUMANN)
  //if(!potentialon){}
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  real[int] U(UUh.ndof),V(UUh.ndof),W(UUh.ndof),VEC(UUh.ndof);
  set(A,eps=eps4solver,solver=mysolver,dimKrylov=150); //,tgv=1e30
  U=A^-1*b;
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  uu1[] = U;
  s11 = dx(uu1); s12 = dy(uu1);
  s21 = dx(uu2); s22 = dy(uu2);
  // ** GAUGE (IN CASE OF SOLUTION IN QUOTIENT SPACE WITH FREDHOLM ALTERNATIVE: PURE NEUMANN)
  //if(tlabel.sum==nblabel){ v = -u(0,0); u = u + v; v = uana(0,0); u = u + v; }
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** POST-PROCESSING
  ofstream Ufile ("./Result/"+geoname+"mesh"+mymesh+"/u.txt");
  Ufile<<uu1[];
  // ** PLOT
  plot(Th,[uu1,uu2],fill=1,value=true,wait=wait4plot,cmm="u");
  [vv1,vv2] = [uu1ana,uu2ana]; plot(Th,[vv1,vv2],fill=1,value=true,wait=wait4plot,cmm="uana");
  // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  // ** CHECK OUTPUT ERRORS
  vv1[] = vv1[]-uu1[]; plot(Th,[vv1,vv2],fill=1,value=true,wait=wait4plot,cmm="uerr");
  t11 = dxuu1ana-s11; //plot(Th,t11,fill=1,value=true,wait=wait4plot,cmm="s1err");
  t12 = dyuu1ana-s12; //plot(Th,t12,fill=1,value=true,wait=wait4plot,cmm="s1err");
  t21 = dxuu2ana-s21; //plot(Th,t21,fill=1,value=true,wait=wait4plot,cmm="s1err");
  t22 = dyuu2ana-s22; //plot(Th,t22,fill=1,value=true,wait=wait4plot,cmm="s1err");
  errl2tabu1(mymesh-1) = sqrt(int2d(Th)(square(vv1)));
  errl2tabu2(mymesh-1) = sqrt(int2d(Th)(square(vv2)));
  errl2tabs11(mymesh-1) = sqrt(int2d(Th)(square(t11)));
  errl2tabs12(mymesh-1) = sqrt(int2d(Th)(square(t12)));
  errl2tabs21(mymesh-1) = sqrt(int2d(Th)(square(t21)));
  errl2tabs22(mymesh-1) = sqrt(int2d(Th)(square(t22)));
  // ** TRACE (DIRICHLET OPERATOR: ESSENTIAL => ERROR STRONG)
  errl2tabtru1(mymesh-1) = 0;
  errl2tabtru2(mymesh-1) = 0;
  for(int i=1; i<=nblabel; i++){ // ?? exclude periodic edges  ??
    ww1[]=0;
    for(int e=0; e<Th.nbe; e++){
      for(int j=0;j<bndryconnectsize(e);j++) if(Th.be(e).label==i) ww1[](bndryconnectivity(e,j)) = 1.;
    } //plot(w1,wait=1,fill=1,cmm="label "+i);
    ww1[] = ww1[].*vv1[];
    cout <<"Linf error trace on "<<i<<" = "<<ww1[].linfty<< endl;
    cout <<"L2 error trace on "<<i<<" = "<<sqrt(int1d(Th,i)(square(vv1)+square(vv2)))<< endl;
    errl2tabtru1(mymesh-1) += int1d(Th,i)(square(vv1));
    errl2tabtru2(mymesh-1) += int1d(Th,i)(square(vv2));
  }
  errl2tabtru1(mymesh-1) = sqrt(errl2tabtru1(mymesh-1));
  errl2tabtru2(mymesh-1) = sqrt(errl2tabtru2(mymesh-1));
  // ** NORMAL TRACE (NEUMANN OPERATOR: NATURAL => ERROR WEAK)
  V = Afull*U; W = V + (-1.)*bfull; vv1[] = W; // ** residual, next evaluated as a _trace_ error (bad: should invert a trace matrix)
  plot(Th,[vv1,vv2],fill=1,value=true,wait=wait4plot,cmm="sdotNerr");
  V = A*U; W = V + (-1.)*b; ww1[] = W; // ** linalg residual
  cout <<"Linf syslin "<< ww1[].linfty/uu1[].linfty <<" vs full " <<vv1[].linfty/uu1[].linfty<< endl;
  errl2tabs1dN(mymesh-1) = 0;
  errl2tabs2dN(mymesh-1) = 0;
  for(int i=1; i<=nblabel; i++){ // ** !! periodic edges interpretation
    ww1[]=0.;
    for(int e=0; e<Th.nbe; e++){
      for(int j=0;j<bndryconnectsize(e);j++) if(Th.be(e).label==i) ww1[](bndryconnectivity(e,j)) = 1.;
    }
    //for(int e=0; e<Th.nbe; e++){
    //  for(int j=0;j<bndryconnectsize(e);j++) if(Th.be(e).label!=i) ww1[](bndryconnectivity(e,j)) = 0.;
    //} // ** uncomment these lines to check that the error is zero _inside_ neumann boundary domains
    ww1[] = ww1[].*vv1[];
    cout <<"Linf error normal trace on "<<i<<" = "<<ww1[].linfty<< endl;
    cout <<"L2 error normal trace on "<<i<<" = "<<sqrt(int1d(Th,i)(square(vv1)+square(vv2)))<< endl;
    errl2tabs1dN(mymesh-1) += int1d(Th,i)(square(vv1));
    errl2tabs2dN(mymesh-1) += int1d(Th,i)(square(vv2));
  }
  errl2tabs1dN(mymesh-1) = sqrt(errl2tabs1dN(mymesh-1));
  errl2tabs2dN(mymesh-1) = sqrt(errl2tabs2dN(mymesh-1));
  //cout <<"Global Linf error normal trace = " <<vv1[].linfty<< endl;

  // ** OUTPUT FILE
  {gpout << H;
   gpout <<"  "<< errl2tabu1(mymesh-1) <<"  "<< errl2tabu2(mymesh-1);
   gpout <<"  "<< errl2tabs11(mymesh-1) <<"  "<< errl2tabs12(mymesh-1);
   gpout <<"  "<< errl2tabs21(mymesh-1) <<"  "<< errl2tabs22(mymesh-1);
   gpout <<"  "<< errl2tabtru1(mymesh-1) <<"  "<< errl2tabtru2(mymesh-1);
   gpout <<"  "<< errl2tabs1dN(mymesh-1) <<"  "<< errl2tabs2dN(mymesh-1);
   gpout << endl;}

}

