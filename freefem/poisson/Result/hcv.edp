///////////////////////////////////////////////////////////////////////////////////
// PROBLEM PARAMETERS
///////////////////////////////////////////////////////////////////////////////////

include "input.idp"

int[int] I(0),J(0); real[int] C(0); // to get Morse storage of a matrix

string gpname = "hcvpoisson.gp";

ofstream gpout(gpname);

// ***********************************

bool isana = true;

// ***********************************

///////////////////////////////////////////////////////////////////////////////////
// COMPUTATIONS (REFERENCE MESH)
///////////////////////////////////////////////////////////////////////////////////

mesh Thref = readmesh("./Mesh/"+geoname+"mesh"+Nmesh+".msh");
fespace Uhref(Thref,uFE);
Uhref uref,ucomp,udiff;
ifstream ufileref("./Result/"+geoname+"mesh"+Nmesh+"/u.txt");
ufileref >> uref[];

int Ncomp; // asumption: mesh labels are ordered increasignly with refinement
if(isana)
{  
  Ncomp = Nmesh;
} else {
  Ncomp = Nmesh-1;
}

///////////////////////////////////////////////////////////////////////////////////
// COMPUTATIONS (CURRENT -- UNREFINED/NESTED -- MESH)
///////////////////////////////////////////////////////////////////////////////////

real[int] eL2(Ncomp);
real[int] eH1(Ncomp);

//mesh Th;

for (int mymesh = 1; mymesh <= Ncomp; mymesh++)
{
  
  mesh Th = readmesh("./Mesh/"+geoname+"mesh"+mymesh+".msh");

  fespace Uh(Th,uFE);

  Uh u;

  ifstream ufile("./Result/"+geoname+"mesh"+mymesh+"/u.txt");

  ufile >> u[];

  plot(Th,u,fill=1,value=true,wait=wait4plot,cmm="FEsol");
    
  ucomp = u;
  
  if(isana)
  {  
    udiff = uana; udiff = udiff-ucomp;
  } else {
    udiff = uref-ucomp;
  }
  
  eL2(mymesh-1) = sqrt( int2d(Thref)(square(udiff)) );
  
  eH1(mymesh-1) = sqrt( int2d(Thref)(square(dx(udiff))+square(dy(udiff))) );

  fespace ThP1(Th,P1);
  ThP1 hloc=hTriangle;
  real[int] htab(ThP1.ndof); htab(0:ThP1.ndof-1)=hloc[];
  real hsum=htab.sum;
  real hnbr=htab.n;
  real H=hsum/hnbr;
  //cout<<H<<endl;//1./(10*mymesh)

  cout << gpname << " : " << H << "  "  << eL2(mymesh-1) << "  "  << eH1(mymesh-1) << endl;
  {gpout << H << "  "  << eL2(mymesh-1) << "  "  << eH1(mymesh-1) << endl;}
  
  real[int] utab(Uh.ndof);
  real[int] utabref(Uhref.ndof);
  utab(0:Uh.ndof-1)=u[];
  utabref(0:Uhref.ndof-1)=uref[];
  real erreur;
  real norme=uref[].linfty;
  erreur=(udiff[].linfty)/norme;
  cout<<"erreur : "<<erreur<<endl;

}

// func f = 2.*cos(x)*sin(y); // cas 2

// func fx = 0;//pi^2*sin(y*pi)*(1./2.+cos(x*pi));
// func fy = 0;//-pi^2*sin(x*pi)*(1./2.+cos(y*pi));
// func uana = sin(y*pi)*(1+cos(x*pi))/2; 
// func vana = -sin(x*pi)*(1+cos(y*pi))/2; 

// exec("echo 'plot \""+gpname+"\" using 1:2 w l\
// pause 2 \
// set term postscript enhanced color \
// set output \"hconvL2.eps\" \
// replot \
// ' | gnuplot");
// 
// exec("echo 'plot \""+gpname+"\" using 1:3 with lines\
// pause 2 \
// set term postscript \
// set output \"hconvH1.eps\" \
// replot \
// quit \
// ' | gnuplot");

// set yrange [0:2.1]
// set style line 1 lt 1 lw 1
// set style line 2 lt 2 lw 3
// set style line 3 lt 6 lw 1
// set term x11
